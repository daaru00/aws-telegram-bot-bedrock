AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Description: Telegram Bot Connector for Bedrock

Parameters:
  TelegramBotToken:
    Type: String
    Description: Telegram bot token
    NoEcho: true
  TelegramIPsWhitelist:
    Type: CommaDelimitedList
    Description: Comma separate list of IPs of permitted senders commands message, leave empty to disable whitelist.
    Default: "149.154.160.0/20,91.108.4.0/22"
  TelegramApiEndpoint:
    Type: String
    Description: "Telegram API endpoint"
    Default: "https://api.telegram.org"
  UsernameWhitelist:
    Type: CommaDelimitedList
    Description: "Telegram allowed usernames, separated by comma"
  MessageModelId:
    Type: String
    Description: "Model identifier"
    Default: "us.anthropic.claude-3-7-sonnet-20250219-v1:0"
  MessageGenerationTimeout:
    Type: Number
    Description: "Message generation timeout in seconds"
    Default: 30
  CompletionModelId:
    Type: String
    Description: "Model identifier"
    Default: "anthropic.claude-instant-v1"
  CompletionGenerationTimeout:
    Type: Number
    Description: "Message completion timeout in seconds"
    Default: 10
  SystemPrompt:
    Type: String
    Description: "Model instruction about how to respond to incoming messages"
    Default: "Your name is Bedrock, you are a chatbot"
  MaxTokens:
    Type: Number
    Description: "Maximum number of tokens to generate"
    Default: 500
  MaxHistoryLength:
    Type: Number
    Description: "Maximum number of message to store in history"
    Default: 10
  KnowledgeBaseId:
    Type: String
    Description: "Knowledge base identifier"
    Default: ""
  DataSourceId:
    Type: String
    Description: "Data source identifier"
    Default: ""
  KnowledgeBaseMaxTokens:
    Type: Number
    Description: "Maximum number of tokens to generate for knowledge base queries"
    Default: "2048"

Globals:
  Function:
    Tracing: Active
    Runtime: nodejs22.x
    CodeUri: src/

Conditions:
  IsKnowledgeBaseIdSet: !Not [!Equals [!Ref KnowledgeBaseId, ""]]
  IsDataSourceIdSet: !Not [!Equals [!Ref DataSourceId, ""]]
  IsKnowledgeBaseEnabled: !And [!Condition IsKnowledgeBaseIdSet, !Condition IsDataSourceIdSet]

Resources:
      
  ##
  # EventBus
  ##

  EventBus:
    Type: AWS::Events::EventBus
    Properties:
      Name: !Ref AWS::StackName

  ##
  # IAM role
  ##

  EventsApiDestinationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - events.amazonaws.com
      Path: '/service-role/'
      Policies:
        - PolicyName: eventbridge-api-destinations
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - events:InvokeApiDestination
                Resource: 
                  - !GetAtt BotApiDestination.Arn

  WebhookEventBridgeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'sts:AssumeRole'
            Principal:
              Service:
                - apigateway.amazonaws.com
      Path: '/service-role/'
      Policies:
        - PolicyName: api-gateway-eventbridge
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - 'events:PutEvents'
                Resource:
                  - !GetAtt EventBus.Arn

  ##
  # EventBus API Connection for Telegram
  ##

  BotApiConnection:
    Type: AWS::Events::Connection
    Properties:
      AuthorizationType: API_KEY
      AuthParameters:
        ApiKeyAuthParameters:
          ApiKeyName: x-api-key
          ApiKeyValue: NoValue

  BotApiDestination:
    Type: AWS::Events::ApiDestination
    Properties:
      Name: !Sub "${AWS::StackName}"
      ConnectionArn: !GetAtt BotApiConnection.Arn
      HttpMethod: POST
      InvocationEndpoint: !Sub "${TelegramApiEndpoint}/bot${TelegramBotToken}/*"
      InvocationRateLimitPerSecond: 10

  ##
  # Telegram API mapping
  ##

  SetWebhookRule:
    Type: AWS::Events::Rule
    Properties:
      State: ENABLED
      EventBusName: !Ref EventBus
      EventPattern:
        detail-type: ['Set Webhook']
      Targets:
        - Id: telegram-destination
          Arn: !GetAtt BotApiDestination.Arn
          RoleArn: !GetAtt EventsApiDestinationRole.Arn
          HttpParameters:
            PathParameterValues:
              - 'setWebhook'
          InputTransformer:
            InputPathsMap:
              "url": "$.detail.url"
            InputTemplate: |
              {
                "url": "<url>"
              }

  SendMessageRule:
    Type: AWS::Events::Rule
    Properties:
      State: ENABLED
      EventBusName: !Ref EventBus
      EventPattern:
        detail-type: ['Send Message']
      Targets:
        - Id: telegram-destination
          Arn: !GetAtt BotApiDestination.Arn
          RoleArn: !GetAtt EventsApiDestinationRole.Arn
          HttpParameters:
            PathParameterValues:
              - 'sendMessage'
          InputTransformer:
            InputPathsMap:
              "chat_id": "$.detail.chat_id"
              "text": "$.detail.text"
            InputTemplate: |
              {
                "chat_id": "<chat_id>",
                "text": "<text>",
                "parse_mode": "HTML"
              }

  SendChatActionRule:
    Type: AWS::Events::Rule
    Properties:
      State: ENABLED
      EventBusName: !Ref EventBus
      EventPattern:
        detail-type: ['Send Chat Action']
      Targets:
        - Id: telegram-destination
          Arn: !GetAtt BotApiDestination.Arn
          RoleArn: !GetAtt EventsApiDestinationRole.Arn
          HttpParameters:
            PathParameterValues:
              - 'sendChatAction'
          InputTransformer:
            InputPathsMap:
              "chat_id": "$.detail.chat_id"
              "action": "$.detail.action"
            InputTemplate: |
              {
                "chat_id": "<chat_id>",
                "action": "<action>"
              }

  ##
  # Rest API endpoint
  ##

  WebhookApiRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Action: 
              - "sts:AssumeRole"
            Principal:
              Service: "apigateway.amazonaws.com"
      Policies:
        - PolicyName: ApiDirectWriteEventBridge
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              Action:
                - events:PutEvents
              Effect: Allow
              Resource:
                - !GetAtt EventBus.Arn

  WebhookApi:
    Type: AWS::Serverless::Api
    Properties:
      Name: !Ref AWS::StackName
      StageName: webhook
      Auth:
        ResourcePolicy:
          IpRangeWhitelist: !Ref TelegramIPsWhitelist
      GatewayResponses:
        DEFAULT_4xx:
          StatusCode: 403
          ResponseTemplates: 
            "text/plain": "Forbidden"
        DEFAULT_5xx:
          StatusCode: 500
          ResponseTemplates:
            "text/plain": "Internal Server Error"
      DefinitionBody:
        swagger: 2.0
        info:
          title: "Telegram Bot Webhook"
        schemes:
          - "https"
        paths:
          /:
            post:
              consumes:
                - "application/json"
              produces:
                - "application/json"
              responses:
                "200":
                  description: "200 response"
              x-amazon-apigateway-integration:
                type: "aws"
                httpMethod: "POST"
                uri: !Sub "arn:aws:apigateway:${AWS::Region}:events:action/PutEvents"
                requestTemplates:
                  application/json: !Sub | 
                    #set($context.requestOverride.header.X-Amz-Target = "AWSEvents.PutEvents")
                    #set($context.requestOverride.header.Content-Type = "application/x-amz-json-1.1")
                    {
                      "Entries": [{
                        "EventBusName": "${EventBus}",
                        "Detail": "$util.escapeJavaScript($input.body).replaceAll("\\'","'")",
                        "DetailType": "Webhook Event Received",
                        "Source": "${AWS::StackName}"
                      }]
                    }
                responses:
                  default:
                    statusCode: "200"
                    responseTemplates:
                      "application/json": "{}"
                credentials: !GetAtt WebhookApiRole.Arn
                passthroughBehavior: "when_no_templates"

  ##
  # StepFunctions for connector management
  ##

  InstallStateMachine:
    Type: AWS::Serverless::StateMachine
    Properties:
      Name: !Sub "${AWS::StackName}-install"
      DefinitionUri: states/install.asl.yaml
      DefinitionSubstitutions:
        EventBusName: !Ref EventBus
        EventSource: !Ref AWS::StackName
        WebhookEndpoint: !Sub "https://${WebhookApi}.execute-api.${AWS::Region}.amazonaws.com/webhook/"
      Policies:
        - EventBridgePutEventsPolicy:
            EventBusName: !Ref EventBus
      Events:
        StackCreated:
          Type: EventBridgeRule
          Properties:
            EventBusName: default
            Pattern:
              source:
                - aws.cloudformation
              detail-type:
                - CloudFormation Stack Status Change
              detail:
                stack-id:
                  - !Ref AWS::StackId
                status-details:
                  status:
                    - CREATE_COMPLETE

  ##
  # Database
  ##

  ChatHistoryBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-chats" 
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true

  AudioBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-audio" 
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: delete-sent-files
            Prefix: "input/"
            ExpirationInDays: 1
            Status: Enabled
          - Id: delete-output-files
            Prefix: "output/"
            ExpirationInDays: 30
            Status: Enabled

  StatusTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-status"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: chat_id
          AttributeType: N
      KeySchema:
        - AttributeName: chat_id
          KeyType: HASH

  ##
  # Integration
  ##

  BedrockIntegrationMessageFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-message"
      Handler: message.handler
      MemorySize: 512
      Timeout: !Ref MessageGenerationTimeout
      Environment:
        Variables:
          SYSTEM_PROMPT: !Ref SystemPrompt
          TOOLS_SSM_PREFIX: !Sub "/${AWS::StackName}/tools/"
          HISTORY_BUCKET: !Ref ChatHistoryBucket
          MAX_HISTORY_LENGTH: !Ref MaxHistoryLength
          MODEL_ID: !Ref MessageModelId
          MAX_TOKENS: !Ref MaxTokens
          TELEGRAM_API_ENDPOINT: !Ref TelegramApiEndpoint
          TELEGRAM_BOT_TOKEN: !Ref TelegramBotToken
          KNOWLEDGE_BASE_ID: !If [IsKnowledgeBaseEnabled, !Ref KnowledgeBaseId, ""]
          KNOWLEDGE_BASE_MODEL_ARN: !If [IsKnowledgeBaseEnabled, !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/${CompletionModelId}", ""]
          KNOWLEDGE_BASE_MAX_TOKENS: !Ref KnowledgeBaseMaxTokens
      Policies:
        - S3CrudPolicy:
            BucketName: !Ref ChatHistoryBucket
        - Statement:
          - Effect: "Allow"
            Action: "ssm:GetParametersByPath"
            Resource: !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/${AWS::StackName}/tools/"
          - Effect: "Allow"
            Action: 
              - "bedrock:InvokeModel"
              - "bedrock:InvokeModelWithResponseStream"
            Resource: "*"
        - !If
          - IsKnowledgeBaseEnabled
          - Statement:
              Effect: "Allow"
              Action: 
                - "bedrock:Retrieve"
                - "bedrock:RetrieveAndGenerate"
              Resource: 
                - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/${KnowledgeBaseId}"
          - !Ref "AWS::NoValue"

  BedrockIntegrationCompletionFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-completion"
      Handler: completion.handler
      Timeout: !Ref CompletionGenerationTimeout
      Environment:
        Variables:
          MODEL_ID: !Ref CompletionModelId
          MAX_TOKENS: !Ref MaxTokens
      Policies:
        - Statement:
          - Effect: "Allow"
            Action: "bedrock:InvokeModel"
            Resource: "*"

  MessageReceivedStateMachine:
    Type: AWS::Serverless::StateMachine
    Properties:
      Name: !Sub "${AWS::StackName}-message"
      DefinitionUri: states/message.asl.yaml
      DefinitionSubstitutions:
        StatusTableName: !Ref StatusTable
        EventBusName: !Ref EventBus
        EventSource: !Ref AWS::StackName
        MessageFunctionArn: !GetAtt BedrockIntegrationMessageFunction.Arn
        CompletionFunctionArn: !GetAtt BedrockIntegrationCompletionFunction.Arn
        ToolFunctionArnPrefix: !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-tools-"
        TranscribeStateMachineArn: !GetAtt TranscribeStateMachine.Arn
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref StatusTable
        - EventBridgePutEventsPolicy:
            EventBusName: !Ref EventBus
        - LambdaInvokePolicy:
            FunctionName: !Ref BedrockIntegrationMessageFunction
        - LambdaInvokePolicy:
            FunctionName: !Ref BedrockIntegrationCompletionFunction
        - LambdaInvokePolicy:
            FunctionName: !Sub "${AWS::StackName}-tools-"
        - Statement:
            - Effect: Allow
              Action:
                - states:StartExecution
              Resource: !GetAtt TranscribeStateMachine.Arn
            - Effect: Allow
              Action:
                - states:DescribeExecution
                - states:StopExecution
              Resource: !Sub "arn:aws:states:${AWS::Region}:${AWS::AccountId}:execution:${TranscribeStateMachine.Name}:*"
            - Effect: Allow
              Action:
                - events:PutTargets
                - events:PutRule
                - events:DescribeRule
              Resource: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/StepFunctionsGetEventsForStepFunctionsExecutionRule"
      Events:
        ReceivedEvent:
          Type: EventBridgeRule
          Properties:
            EventBusName: !Ref EventBus
            Pattern:
              source:
                - !Ref AWS::StackName
              detail-type:
                - 'Webhook Event Received'
              detail:
                message:
                  from:
                    username: !Ref UsernameWhitelist

  ##
  # Transcribe
  ##

  DownloadFileFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-download"
      Handler: download.handler
      MemorySize: 512
      Timeout: 30
      Environment:
        Variables:
          BUCKET_NAME: !Ref AudioBucket
          TELEGRAM_API_ENDPOINT: !Ref TelegramApiEndpoint
          TELEGRAM_BOT_TOKEN: !Ref TelegramBotToken
      Policies:
        - S3CrudPolicy:
            BucketName: !Ref AudioBucket

  GetTranscriptionFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-get-transcription"
      Handler: transcription.handler
      Timeout: 6
      Environment:
        Variables:
          BUCKET_NAME: !Ref AudioBucket
      Policies:
        - S3ReadPolicy:
            BucketName: !Ref AudioBucket

  TranscribeStateMachine:
    Type: AWS::Serverless::StateMachine
    Properties:
      Name: !Sub "${AWS::StackName}-transcribe"
      DefinitionUri: states/transcribe.asl.yaml
      DefinitionSubstitutions:
        EventBusName: !Ref EventBus
        EventSource: !Ref AWS::StackName
        DownloadFileFunctionArn: !GetAtt DownloadFileFunction.Arn
        GetTranscriptionFunctionArn: !GetAtt GetTranscriptionFunction.Arn
        OutputBucketName: !Ref AudioBucket
      Policies:
        - EventBridgePutEventsPolicy:
            EventBusName: !Ref EventBus
        - LambdaInvokePolicy:
            FunctionName: !Ref DownloadFileFunction
        - LambdaInvokePolicy:
            FunctionName: !Ref GetTranscriptionFunction
        - S3CrudPolicy:
            BucketName: !Ref AudioBucket
        - Statement:
            - Effect: Allow
              Action:
                - transcribe:StartTranscriptionJob
                - transcribe:GetTranscriptionJob
              Resource: '*'

  ##
  # Tools
  ##

  DateTimeToolFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-datetime"
      Handler: tools/datetime.handler
      Timeout: 6
      MemorySize: 128

  DateTimeToolParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/datetime"
      Type: String
      Value: !Sub |
        {
          "name": "datetime",
          "description": "Get the current date and time",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {},
              "required": []
            }
          }
        }

  HttpToolFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-http"
      Handler: tools/http.handler
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          MODEL_ID: !Ref CompletionModelId
          MAX_TOKENS: !Ref MaxTokens
      Policies:
        - Statement:
          - Effect: "Allow"
            Action: "bedrock:InvokeModel"
            Resource: "*"

  HttpToolParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/http"
      Type: String
      Value: !Sub |
        {
          "name": "http",
          "description": "Read the content of a valid and existing website",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {
                "url": {
                  "type": "string",
                  "format": "uri",
                  "description": "The website URL"
                }
              },
              "required": [
                "url"
              ]
            }
          }
        }

  MemorySaveToolFunction:
    Condition: IsKnowledgeBaseEnabled
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-memory-save"
      Handler: tools/memory.save
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          KNOWLEDGE_BASE_ID: !Ref KnowledgeBaseId
          DATA_SOURCE_ID: !Ref DataSourceId
      Policies:
        - Statement:
          - Effect: "Allow"
            Action: 
              - "bedrock:StartIngestionJob"
              - "bedrock:IngestKnowledgeBaseDocuments"
            Resource: 
              - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/${KnowledgeBaseId}"

  MemorySaveToolParameter:
    Condition: IsKnowledgeBaseEnabled
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/memory-save"
      Type: String
      Value: !Sub |
        {
          "name": "memory-save",
          "description": "Save a text into the knowledge base. Use this tool to store information about the user your are chatting with that can be retrieved later. You decide when to use this tool when you feel information should be saved. Don't mention that you've saved it to the user you're chatting to, just continue with the conversation.",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {
                "text": {
                  "type": "string",
                  "description": "The text to save"
                }
              },
              "required": [
                "text"
              ]
            }
          }
        }

  MemorySearchToolFunction:
    Condition: IsKnowledgeBaseEnabled
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-memory-search"
      Handler: tools/memory.search
      Timeout: 30
      MemorySize: 512
      Environment:
        Variables:
          KNOWLEDGE_BASE_ID: !Ref KnowledgeBaseId
          KNOWLEDGE_BASE_MODEL_ARN: !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/${CompletionModelId}"
          KNOWLEDGE_BASE_MAX_TOKENS: !Ref KnowledgeBaseMaxTokens
      Policies:
        - Statement:
          - Effect: "Allow"
            Action: 
              - "bedrock:Retrieve"
              - "bedrock:RetrieveAndGenerate"
            Resource: 
              - !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/${KnowledgeBaseId}"
          - Effect: "Allow"
            Action: 
              - "bedrock:InvokeModel"
            Resource: "*"

  MemorySearchToolParameter:
    Condition: IsKnowledgeBaseEnabled
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/memory-search"
      Type: String
      Value: !Sub |
        {
          "name": "memory-search",
          "description": "Search in the knowledge base. Use this tool to retrieve information about the user you are chatting with that has been previously saved. You decide when to use this tool when you feel you need information about the user. Don't mention to the user you're chatting with that you've retrieved their information.",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {
                "query": {
                  "type": "string",
                  "description": "The query to search in the knowledge base"
                }
              },
              "required": [
                "query"
              ]
            }
          }
        }

  ScheduleRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - scheduler.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: '/service-role/'
      Policies:
        - PolicyName: execute-step-function
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource: 
                  - !Ref MessageReceivedStateMachine

  ScheduleCreateToolFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-schedule-create"
      Handler: tools/schedule.create
      Timeout: 6
      MemorySize: 128
      Environment:
        Variables:
          STEP_FUNCTION_ARN: !Ref MessageReceivedStateMachine
          SCHEDULER_ROLE_ARN: !GetAtt ScheduleRole.Arn
      Policies:
        - Statement:
          - Effect: "Allow"
            Action:  "scheduler:CreateSchedule"
            Resource: "*"
          - Effect: "Allow"
            Action: "iam:PassRole"
            Resource: !GetAtt ScheduleRole.Arn

  ScheduleCreateToolParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/schedule-create"
      Type: String
      Value: !Sub |
        {
          "name": "schedule-create",
          "description": "Schedule a message that will be sent to yourself. You can use this tool to schedule messages (eg: 'send a message to wish a good trip') to yourself in the future at the specified time, by cron expression and you can choose if it should be recurring or not (if not will be deleted after the first execution). The tool respond with the id of the created schedule.",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {
                "message": {
                  "type": "string",
                  "description": "The message to schedule as your reminder"
                },
                "expression": {
                  "type": "string",
                  "description": "The AWS schedule expression in cron format: 'at(yyyy-mm-ddThh:mm:ss)' for a specific date and time, 'rate(value unit)' for a rate expression (e.g., 'rate(1 day)' or 'rate(2 hours)'), 'cron(minutes hours day_of_month month day_of_week year)' for a cron expression (e.g., 'cron(0 12 * * ? *)' for every day at noon)."
                },
                "recurring": {
                  "type": "boolean",
                  "description": "If true, the schedule will be recurring, otherwise it will be deleted after the first execution. Default is false."
                }
              },
              "required": [
                "message",
                "expression"
              ]
            }
          }
        }

  ScheduleListToolFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-schedule-list"
      Handler: tools/schedule.list
      Timeout: 30
      MemorySize: 256
      Policies:
        - Statement:
          - Effect: "Allow"
            Action:  
              - "scheduler:ListSchedules"
              - "scheduler:GetSchedule"
            Resource: "*"

  ScheduleListToolParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/schedule-list"
      Type: String
      Value: !Sub |
        {
          "name": "schedule-list",
          "description": "List all the scheduled messages you have created. You can use this tool to list all the scheduled messages you have created with the schedule-create tool.",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {},
              "required": []
            }
          }
        }
  
  ScheduleRemoveToolFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tools-schedule-remove"
      Handler: tools/schedule.remove
      Timeout: 6
      MemorySize: 128
      Policies:
        - Statement:
          - Effect: "Allow"
            Action:  "scheduler:DeleteSchedule"
            Resource: "*"

  ScheduleRemoveToolParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/tools/schedule-remove"
      Type: String
      Value: !Sub |
        {
          "name": "schedule-remove",
          "description": "Remove a scheduled message by id. You can use this tool to remove a scheduled message that you previously created with the schedule-create tool.",
          "inputSchema": {
            "json": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The id of the schedule to remove"
                }
              },
              "required": [
                "id"
              ]
            }
          }
        }
